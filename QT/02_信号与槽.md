信号与槽是Qt提供的一个种控件之间的通信机制。当一个控件发生某个事件时，我们希望通知其他控件进行相应的动作，这时候我们就可以用信号与槽机制来实现

#### 什么是信号？

- 在 Qt 中，信号（Signal） 是一种特殊的成员函数声明。
- 信号函数只能在类中声明，并且总是公有的，不论是在private或protect修饰符下。
- 信号函数只有声明，我们不能够手动定义它，它的具体实现是由Qt中的`moc`(元对象编译器)自动生成
- 信号函数返回值总是`void`

#### 什么是槽？

槽：响应特定信号而被调用的函数。所以槽又可以称为槽函数。Qt 控件有很多预定义槽函数，槽函数也可以自己自定义。

槽函数的特点

- 槽是普通的 C++ 函数，只要是可调用对用都可以作为槽（例如：普通函数，成员函数，静态函数，仿函数，lambda表达式，function对象）
- 通过信号-槽连接，任何组件都可以调用槽，不受访问级别限制

#### 连接信号与槽

`connect(发送者，信号，接收者，槽函数)`

- 发送者是Object对象指针
- 信号是成员函数的函数指针
- 接收者可以有，也可以没有
- 槽函数是任何可调用对象
- 信号函数的参数个数<=槽函数的参数个数（并且从左到右要依次匹配）

```C++
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    //槽函数为成员函数
    QPushButton *bt1 = new QPushButton(this);
    bt1->setText("close");
    connect(bt1, &QPushButton::clicked,this, &MainWindow::close);
	//槽函数为普通函数
    QPushButton *bt2 = new QPushButton(this);
    bt2->setText("print");
    bt2->move(0,50);
    connect(bt2, &QPushButton::clicked,myPrint);
	//槽函数为lambda表达式
    QPushButton *bt3 = new QPushButton(this);
    bt3->setText("Lambda");
    bt3->move(0,100);
    connect(bt3, &QPushButton::clicked,[](){std::cout<<"Lambda enter"<<std::endl;});
	//槽函数为静态成员函数
    QPushButton *bt4 = new QPushButton(this);
    bt4->setText("static");
    bt4->move(0,150);
    connect(bt4, &QPushButton::clicked,&MainWindow::test);
	//成员函数为仿函数
    QPushButton *bt5 = new QPushButton(this);
    bt5->setText("functor");
    bt5->move(0,200);
    function f;
    connect(bt5, &QPushButton::clicked, f);
}
```

- 注意只有槽函数为成员函数时必须得指定信号的接收者；对于其它可调用对象，接收者可有可无。

#### 连接规则

- 可以将多个信号连接到一个槽
- 一个信号可以连接到多个槽（当触发时，槽会按连接顺序依次执行）
- 信号可以与信号进行连接

#### 信号与槽的连接在以下几种情况下会被破坏（断开）：

1. **对象销毁（最常见）**

这是 Qt 信号槽机制最核心的安全特性。当**发送者（sender）**或**接收者（receiver）**对象被销毁时，所有与该对象相关的连接都会被**自动断开**。

**示例：接收者销毁**
```cpp
QPushButton *button = new QPushButton("Click me");
QLabel *label = new QLabel("Status");

// 建立连接
connect(button, &QPushButton::clicked, label, &QLabel::clear);

// ...一段时间后...
delete label; // label 被销毁

// 此时点击按钮，信号会发出，但由于连接已自动断开，不会有任何操作，也不会崩溃
button->click(); 
```

**示例：发送者销毁**
```cpp
QTimer *timer = new QTimer();
MyObject *receiver = new MyObject();

connect(timer, &QTimer::timeout, receiver, &MyObject::onTimeout);
timer->start(1000);

// ...一段时间后...
delete timer; // timer 被销毁，连接自动断开
```

2. **显式调用 `QObject::disconnect()`**

你可以手动断开连接，`disconnect()` 函数有多种重载形式，可以实现不同粒度的断开操作。

**a. 断开特定连接（使用 `QMetaObject::Connection`）**
```cpp
QTimer *timer = new QTimer();
// 保存 connect 返回的连接对象
QMetaObject::Connection conn = connect(timer, &QTimer::timeout, this, &MyClass::onTimeout);

// ...
// 断开这个特定的连接
QObject::disconnect(conn);
```

**b. 断开特定信号与特定槽的连接**
```cpp
// 断开 button 的 clicked 信号与 this 的 onButtonClicked 槽的连接
disconnect(button, &QPushButton::clicked, this, &MyClass::onButtonClicked);
```

**c. 断开某个对象上的所有信号**
```cpp
// 断开 button 对象发出的所有信号
disconnect(button, nullptr, nullptr, nullptr);
```

**d. 断开所有连接到某个对象的槽**
```cpp
// 断开所有连接到 this 对象的槽函数
disconnect(nullptr, nullptr, this, nullptr);
```

3. **上下文对象销毁（针对非成员函数槽）**

当使用 Lambda 表达式、仿函数或自由函数作为槽时，如果 `connect` 时提供了**上下文对象（context object）**，那么当该上下文对象被销毁时，连接也会被自动断开。

```cpp
QPushButton *button = new QPushButton();
QObject *context = new QObject(); // 创建一个上下文对象

// 连接 Lambda，并指定 context 为上下文
connect(button, &QPushButton::clicked, context, []() {
    qDebug() << "Button clicked!";
});

// ...
delete context; // 上下文对象被销毁

// 此时点击按钮，连接已断开，Lambda 不会执行
button->click();
```
如果连接时没有提供上下文对象，则该连接的生命周期通常会与发送者（sender）绑定。

#### 对于非成员函数，信号的接收者最好指定

- 行为：当接收者对象被销毁时，这个信号槽连接会自动断开。

- 优点：这是 Qt 自动内存管理和防止悬挂指针的核心机制。它能确保当槽函数所依赖的环境（比如 Lambda 中捕获的对象）不存在时，连接也随之失效，从而避免程序崩溃。

#### 信号怎么手动发送

- 使用emit关键字发送信号

  ```C++
  class Counter : public QObject
  {
      Q_OBJECT
  
  public:
      Counter(int initial = 0) : m_value(initial) {}
      
      void setValue(int value) {
          if (value != m_value) {
              int oldValue = m_value;
              m_value = value;
              
              // 发送信号
              emit valueChanged(m_value);           // 发送新值
              emit rangeChanged(oldValue, m_value); // 发送变化范围
              
              if (m_value > 100) {
                  emit overflow();  // 条件性发送信号
              }
          }
      }
  
  signals:
      void valueChanged(int newValue);
      void rangeChanged(int oldValue, int newValue);
      void overflow();
  
  private:
      int m_value;
  };
  ```

  

- emit关键字的本质

  ```C++
  // emit 实际上是一个空宏定义
  #define emit
  
  // 因此这两种写法是等价的：
  emit valueChanged(42);
  valueChanged(42);  // 直接调用，没有 emit 关键字
  
  // 但推荐使用 emit，因为它：
  // 1. 提高代码可读性
  // 2. 明确标识这是信号发送
  // 3. 便于代码搜索和维护
  ```

  

#### 补充：函数存在重载时如何确定某个函数的指针

你可以先定义一个具有确切签名的函数指针变量，然后将重载函数名赋给它。编译器会根据变量的类型自动推断出你想要的是哪个版本的函数。

```C++
#include <iostream>

struct Printer {
    void print(int i) { std::cout << "int: " << i << std::endl; }
    void print(double d) { std::cout << "double: " << d << std::endl; }
};

int main() {
    // 声明一个明确类型的函数指针变量
    void (Printer::*int_print_ptr)(int) = &Printer::print;
    void (Printer::*double_print_ptr)(double) = &Printer::print;

    Printer p;
    (p.*int_print_ptr)(10);
    (p.*double_print_ptr)(3.14);
    
    return 0;
}
```







