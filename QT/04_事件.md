## 事件过滤器

- 提供另一种处理事件的方法
- 可以把事件的处理交给其他对象来处理
- 安装事件过滤器可以阻断事件的进一步的传递
- 一个事件过滤器可以处理多个对象的多个事件，所以比较灵活
- Event Filter适用监视另一个对象的行为或当创建子类化成本过高时。

```txt
[操作系统/Qt] -> 产生一个鼠标点击事件
      |
      V
[1. Qt应用程序事件队列]
      |
      V
[2. QCoreApplication::notify()] (所有事件的入口)
      |
      |-----------------------------------------------------> [2a. 应用程序级事件过滤器]
      |                                                        (QApplication::installNativeEventFilter)
      |                                                        如果过滤器处理并返回 true -> [事件结束]
      |                                                        否则 -> (继续)
      V
[3. 目标组件的事件过滤器]
   (widget->installEventFilter(filterObj))
   (可以有多个，按后装先调用的顺序执行)
      |
      |----> for each filter in reverse order of installation:
      |        if (filter->eventFilter(target, event) == true)
      |            -> [事件结束]
      |
      V  (所有过滤器都返回 false)
[4. 目标组件的 QObject::event() 函数]
      |
      |----> event() 函数像一个总开关，根据事件类型调用具体的事件处理器
      |      例如 event->type() == QEvent::MouseButtonPress
      |      则调用 virtual void mousePressEvent(QMouseEvent*)
      |
      V
[5. 目标组件的具体事件处理器]
   (例如 widget->mousePressEvent(event))
      |
      |----------------------------------------------------> [5a. 处理器调用了 event->accept()]
      |         (或者什么都不调用，accept 是默认行为)            -> [事件结束]
      |
      |----------------------------------------------------> [5b. 处理器调用了 event->ignore()]
      |                                                        -> [进入事件传播阶段]
      V
[6. 事件传播给父组件]
  	调用父组件对应的event()函数
      |
      |----> 和步骤 [5] 一样，父组件可以选择 accept 或 ignore
      |      如果 parent->ignore() -> [继续传播给父组件的父组件]
      |      如果 parent->accept() -> [事件结束]
      |
      V
[7. ...一路向上传播，直到顶层窗口]
      |
      V
[8. 顶层窗口也 ignore() 了事件]
      |
      V
[事件被最终丢弃]
```

## 自定义事件

自定义事件通常需要以下几个步骤：

1.  **创建一个继承自 `QEvent` 的子类**。这个子类将代表你的自定义事件。你需要重写它的构造函数，并为它定义一个唯一的事件类型ID。
2.  **（可选）在事件类中添加需要传递的数据成员**。如果你的事件需要携带额外的信息，可以在这个子类中添加相应的成员变量。
3.  **在需要接收事件的 `QObject` 子类（通常是 `QWidget`）中重写 `customEvent()` 方法**。当事件循环分发一个自定义事件给这个对象时，这个方法就会被调用。
4.  **使用 `QCoreApplication::postEvent()` 或 `QCoreApplication::sendEvent()` 来发送事件**。`postEvent()` 是异步的，它会将事件放入事件队列，Qt 会在稍后处理它（这是线程安全的，也是更常用的方法）。`sendEvent()` 是同步的，它会立即处理事件。

为了给你一个更清晰的展示，我将通过网络搜索查找一个典型的 Qt 自定义事件的实现示例。

[1 tool called]

好的，在 Qt 中创建自定义事件是一个很常见的需求，通常用于在不同对象之间传递自定义数据。这可以解耦组件，让代码更清晰。

实现自定义事件主要有以下三个步骤：

### 1. 定义自定义事件类

首先，你需要创建一个继承自 `QEvent` 的类。最关键的是要为这个新的事件类型定义一个唯一的ID。Qt 规定用户自定义事件的类型ID应该介于 `QEvent::User` 和 `QEvent::MaxUser` 之间。

这是一个例子：

**`customevent.h`**
```cpp
#include <QEvent>
#include <QString>

class CustomEvent : public QEvent
{
public:
    // 定义一个静态常量作为事件的类型ID
    // QEvent::User是Qt预留给用户自定义事件的起始ID
    static const QEvent::Type CustomEventType;

    explicit CustomEvent(const QString &message)
        : QEvent(CustomEventType), m_message(message) {}

    QString getMessage() const { return m_message; }

private:
    QString m_message;
};
```

**`customevent.cpp`**
```cpp
#include "customevent.h"

// 初始化静态类型ID
const QEvent::Type CustomEvent::CustomEventType = static_cast<QEvent::Type>(QEvent::User + 1);
```

### 2. 发送事件

你可以使用 `QCoreApplication::postEvent()` (异步) 或 `QCoreApplication::sendEvent()` (同步) 来将事件发送给一个 `QObject` 对象。

*   **`postEvent()`**: 将事件放入事件队列中，然后立即返回。事件循环会在稍后处理该事件。这是线程安全的，也是最常用的方式。
*   **`sendEvent()`**: 立即处理事件，绕过事件队列。

**发送事件的例子：**
```cpp
#include <QCoreApplication>
#include "customevent.h"

// ... 假设 'receiverObject' 是一个 QObject* 类型的指针
CustomEvent* event = new CustomEvent("Hello, this is a custom event!");
QCoreApplication::postEvent(receiverObject, event);
```
**注意**: 使用 `postEvent` 时，Qt 会取得事件对象的所有权，并在处理完后自动删除它。因此，你必须在堆上（使用 `new`）创建事件对象，并且不能在发送后手动删除它。

### 3. 处理事件

最后，在接收事件的 `QObject` 子类中，你需要重写 `event()` 方法来捕获并处理你的自定义事件。

**处理事件的例子：**
```cpp
// 在你的接收者类中 (例如 MyWidget.cpp)
#include "customevent.h"
#include <QDebug>

bool MyWidget::event(QEvent *event)
{
    // 检查事件类型是否是我们的自定义事件类型
    if (event->type() == CustomEvent::CustomEventType)
    {
        // 将 QEvent* 安全地转换为你的自定义事件类型
        CustomEvent *myEvent = static_cast<CustomEvent *>(event);
        qDebug() << "Custom event received with message:" << myEvent->getMessage();

        // 返回true表示事件已经被处理，不需要再传递给父类
        return true;
    }

    // 对于其他类型的事件，调用基类的event()方法进行默认处理
    return QWidget::event(event);
}
```

通过这三个步骤，你就可以在你的Qt应用程序中完整地实现和使用自定义事件了。
